<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>Gagarin</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100% }
    </style>
</head>

<body onload="init()">
<script src="js/three.js"></script>
<script src="js/stats.min.js"></script>
<script src="js/dat.gui.min.js"></script>
<script src="js-r79/TrackballControls.js"></script>
<script src="js/AnaglyphEffect.js"></script>

<!-- ---------------- Custom Shader Code ------------------------ -->
<script id="vertexShader" type="x-shader/x-vertex">
uniform vec3 viewVector;
uniform float c;
uniform float p;
varying float intensity;
void main()
{
  vec3 vNormal = normalize( normalMatrix * normal );
	vec3 vNormel = normalize( normalMatrix * viewVector );
	intensity = pow( c - dot(vNormal, vNormel), p );

  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>

<!-- fragment shader a.k.a. pixel shader -->
<script id="fragmentShader" type="x-shader/x-vertex">
uniform vec3 glowColor;
varying float intensity;
void main()
{
	vec3 glow = glowColor * intensity;
    gl_FragColor = vec4( glow, 0.08 );
}
</script>

<script>
    // Globális változók
    var WIDTH, HEIGHT, aspectRatio;
    var renderer;
    var scene, camera;
    var geometry, material, mesh;
    var ambientLight;
    var stats;
    var meshAstronaut = new THREE.Mesh();
    var meshVisor= new THREE.Mesh();
    var controls;
    var effect;
    var THREEDEE = false;
    var EXPLODE = false;
    var explosionGeometry = new THREE.Geometry();
    var explosionGeometry_base;


    // FPS COUNTER --------------------------------------------------
    function addStatsObject() {
      stats = new Stats();
      stats.setMode(0);

      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0px';
      stats.domElement.style.top = '0px';
      document.body.appendChild( stats.domElement );
    }

    // CONTROL GUI --------------------------------------------------
    function addControlGui( controlObject ) {
        var gui = new dat.GUI( { autoPlace: false });
        gui.add( controlObject, 'AnaglyphEffect' );
        gui.add( controlObject, 'ExplodeEarth');
        gui.add( controlObject, 'ResetEarth');
        gui.domElement.style.position = 'absolute';
        gui.domElement.style.top = '0px';
        gui.domElement.style.right = '0px';
        document.body.appendChild( gui.domElement );
    }

    var RenderController = function () {
        this.AnaglyphEffect = function() {
            THREEDEE = !THREEDEE;
        };
        this.ExplodeEarth = function() {
          EXPLODE = true;
        }
        this.ResetEarth = function() {
          EXPLODE = false;
          resetEarth();
        }
    };

    // INITIALIZER ---------------------------------------------------
    function init() {

        var manager = new THREE.LoadingManager();
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        aspectRatio = WIDTH / HEIGHT;
        renderer = new THREE.WebGLRenderer( { antialias: false } );
        renderer.setSize( WIDTH, HEIGHT );
        renderer.setClearColor( 0x00001a );
        document.body.appendChild( renderer.domElement );

        effect = new THREE.AnaglyphEffect( renderer );
        effect.setSize( window.innerWidth || 2, window.innerHeight || 2 );

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0007);
















        // CAMERA ----------------------------------------------------------------------------
        camera = new THREE.PerspectiveCamera( 75, aspectRatio, 0.1, 1000 );
        camera.position.z = 15;
        camera.lookAt( scene.position );


















        // MODELS ----------------------------------------------------------------------------
        // sphere
        var textureLoader = new THREE.TextureLoader(manager);
        var texture = textureLoader.load( 'assets/tc-earth_daymap.jpg' );
        geometry = new THREE.SphereGeometry( 3, 50, 30);
        material = new THREE.MeshPhongMaterial();
        material.map = texture;
        mesh = new THREE.Mesh( geometry, material );
        mesh.rotation.z = 0.2;
        mesh.position.x -= 10;
        scene.add( mesh );



        	// create custom material from the shader code above
        	//   that is within specially labeled script tags
        	var customMaterial = new THREE.ShaderMaterial(
        	{
        	    uniforms:
        		{
        			"c":   { type: "f", value: 1.0 },
        			"p":   { type: "f", value: 1.4 },
        			glowColor: { type: "c", value: new THREE.Color(0xccffff) },
        			viewVector: { type: "v3", value: camera.position }
        		},
        		vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
        		fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
        		side: THREE.FrontSide,
        		blending: THREE.AdditiveBlending,
        		transparent: true
        	}   );

        	this.earthGlow = new THREE.Mesh( geometry.clone(), customMaterial.clone() );
          earthGlow.position = geometry.position;
          earthGlow.position.x -= 10;
        	earthGlow.scale.multiplyScalar(1.1);
        	scene.add( earthGlow );




        // astronaut
        var textureAstronaut = textureLoader.load( 'assets/astronaut.png' );
        var loader = new THREE.JSONLoader(manager);
        loader.load( 'assets/astronaut.json', function ( geometry ) {
            material = new THREE.MeshLambertMaterial( { color: 0xf2f2f2, wireframe: false, side: THREE.DoubleSide } );
            material.map = textureAstronaut;
            meshAstronaut = new THREE.Mesh( geometry, material );
            meshAstronaut.scale.set( 3, 3, 3 );
            scene.add(meshAstronaut);
        });

        // visor
        var textureVisor = textureLoader.load( 'assets/visor.png' );
        loader.load( 'assets/visor.json', function ( geometry ) {
            material = new THREE.MeshLambertMaterial( { color: 0xf2f2f2, wireframe: false, side: THREE.DoubleSide } );
            material.map = textureVisor;
            meshVisor = new THREE.Mesh( geometry, material );
            meshVisor.scale.set( 3, 3, 3 );
            scene.add(meshVisor);
        });

        // asteroids
        var textureAsteroid = textureLoader.load( 'assets/asteroid.jpg' );
        group = new THREE.Object3D();
        loader.load( 'assets/asteroid.json', function ( geometry ) {
            material = new THREE.MeshLambertMaterial( { color: 0xf2f2f2, wireframe: false, side: THREE.DoubleSide } );
            material.map = textureAsteroid;
            meshAsteroid = new THREE.Mesh( geometry, material );
            for ( i = 0; i < 100; i ++ ) {
                instance = meshAsteroid.clone();
                instance.position.x = Math.random() * 1000 - 500;
                instance.rotation.x = Math.random() * 800 - 400;
                instance.position.y = Math.random() * 1000 - 500;
                instance.rotation.y = Math.random() * 800 - 400;
                instance.position.z = Math.random() * 1000 - 500;
                instance.rotation.z = Math.random() * 800 - 400;
                instance.scale.x = Math.random() * 4 + 1;
                instance.scale.y = Math.random() * 4 + 1;
                instance.scale.z = Math.random() * 4 + 1;
                group.add( instance );
            }
            //meshAsteroid.scale.set( 3, 3, 3 );
            scene.add(group);
        });

        // moon
        var textureMoon = textureLoader.load( 'assets/moon.jpg' );
        var bump = textureLoader.load( 'assets/moonbump.jpg' );
        var materialMoon = new THREE.MeshPhongMaterial();
        var geometryMoon = new THREE.SphereGeometry( 3, 50, 30);
        materialMoon.map = textureMoon;
        materialMoon.bumpMap = bump;
        materialMoon.bumpScale = 0.2;
        var meshMoon = new THREE.Mesh( geometryMoon, materialMoon );
        meshMoon.position.x += 8;
        scene.add( meshMoon );











        // particles
        var textureParticles = textureLoader.load( 'assets/star.jpg' );
        var particlesGeometry = new THREE.Geometry();
        particleCount = 100000;
        for( i = 0; i < particleCount; i++ ) {
            var vertex = new THREE.Vector3();
            vertex.x = Math.random() * 6000 - 3000;
            vertex.y = Math.random() * 6000 - 3000;
            vertex.z = Math.random() * 6000 - 3000;
            particlesGeometry.vertices.push( vertex );
        }
        var particlesMaterial = new THREE.PointsMaterial( {size: 2, color: 0xffffff, sizeAttenuation: true } );
        particlesMaterial.map = textureParticles;
        particles = new THREE.Points( particlesGeometry, particlesMaterial );
        scene.add( particles );



        // explosion particles
        count = 0;
        while (count < 100000) {
          var e_vertex = new THREE.Vector3();
          var phi = Math.random() * Math.PI * 2;
          var theta = Math.acos(Math.random() * 2 - 1);
          var r = 2.8 * Math.cbrt(Math.random());
          e_vertex.x = r * Math.sin(theta) * Math.cos(phi);
          e_vertex.y = r * Math.sin(theta) * Math.sin(phi);
          e_vertex.z = r * Math.cos(theta);
          explosionGeometry.vertices.push( e_vertex );
          count++;
        }
        var explosionMaterial = new THREE.PointsMaterial( {size: 0.1, color: 0xff0000, sizeAttenuation: true } );
        explosion = new THREE.Points( explosionGeometry, explosionMaterial );
        explosionGeometry_base = explosionGeometry;
        scene.add( explosion );














        // LIGHTS ----------------------------------------------------------------------------

        var sLight = new THREE.SpotLight( 0xffffff, 1 );
        sLight.position.set(0,10,15);
        sLight.angle = Math.PI / 2;
        sLight.target = mesh;
        scene.add(sLight);

        var ambientLight = new THREE.AmbientLight( 0x404040 ); // soft white light
        scene.add( ambientLight );

        var pointLight = new THREE.PointLight( 0x404040, 1, 100 );
        pointLight.position.set( 0, 100, 250 );
        scene.add( pointLight );



        controls = new THREE.TrackballControls( camera, renderer.domElement );
        controls.rotateSpeed = 5.0;
        controls.panSpeed = 1.0;

        window.addEventListener( 'resize', handleWindowResize, false );
        ctrl = new RenderController();
        addControlGui( ctrl );
        addStatsObject();
        render();
    }

    function handleWindowResize() {
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        console.log( 'WIDTH=' + WIDTH + '; HEIGHT=' + HEIGHT );
        renderer.setSize( WIDTH, HEIGHT );
        aspectRatio = WIDTH / HEIGHT;
        camera.aspect = aspectRatio;
        camera.updateProjectionMatrix();
        effect.setSize( window.innerWidth, window.innerHeight );
    }

    function directionalVector(v1, v2) {
      return new THREE.Vector3(v2.x - v1.x, v2.y - v1.y, v2.z - v1.z);
    }

    function normalizeVector(v) {
      length = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
      return new THREE.Vector3(v.x / length, v.y / length, v.z / length);
    }

    function explode() {
      origin = new THREE.Vector3(0, 0, 0);

      for (i=0; i<explosionGeometry.vertices.length; i++) {
        direction = normalizeVector(directionalVector(origin, explosionGeometry.vertices[i]));
        explosionGeometry.vertices[i].x += direction.x;
        explosionGeometry.vertices[i].y += direction.y;
        explosionGeometry.vertices[i].z += direction.z;
      }
      explosionGeometry.verticesNeedUpdate = true;
    }

    function resetEarth() {
      for (i=0; i<explosionGeometry.vertices.length; i++) {
        phi = Math.random() * Math.PI * 2;
        theta = Math.acos(Math.random() * 2 - 1);
        r = 2.8 * Math.cbrt(Math.random());
        explosionGeometry.vertices[i].x = r * Math.sin(theta) * Math.cos(phi);
        explosionGeometry.vertices[i].y = r * Math.sin(theta) * Math.sin(phi);
        explosionGeometry.vertices[i].z = r * Math.cos(theta);
      }
      explosionGeometry.verticesNeedUpdate = true;
    }


    var render = function () {

        requestAnimationFrame( render );


        mesh.rotation.y += 0.0005;
        meshAstronaut.rotation.x += 0.0008;
        meshAstronaut.rotation.y += 0.0008;
        particles.rotation.x += 0.0001;
        particles.rotation.y -= 0.0001;
        meshVisor.rotation.x += 0.0008;
        meshVisor.rotation.y += 0.0008;
        group.rotation.x += 0.0003;
        group.rotation.y += 0.0003;

        if (EXPLODE)
          explode();

        controls.update();
        if (THREEDEE)
          effect.render( scene, camera );
        else
          renderer.render( scene, camera );
        stats.update();
    };

</script>
</body>
</html>
